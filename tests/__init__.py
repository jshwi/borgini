"""
tests
=====

Test package for ``borgini``.
"""
import datetime
import getpass
import os
import re
import shutil
import socket
import typing as t

import pytest

USER = getpass.getuser()
HOST = socket.gethostname()
BORG = "borg"
BORG_BIN = shutil.which(BORG) if shutil.which(BORG) else BORG
REPONAME = "reponame"
DATETIME = "2021-02-07T16:12:58"
SHUTIL_WHICH = "shutil.which"
NEWPROFILE = "newprofile"
CONFIG_INI = "config.ini"
VIM = "vim"
REPOPATH = "repopath"
DEVNULL = "/dev/null"
DRY = "--dry"
DEFAULT = "default"
INITIALIZE_FILES = "initialize_files"
TMPCONFIGDIR = "tmpconfigdir"


class NoColorCapsys:
    """Capsys but with a regex to remove ANSI escape codes.

    Class is preferable for this as we can instantiate the instance as a
    fixture that also contains the same attributes as capsys.

    We can make sure that the class is instantiated without executing
    capsys immediately thus losing control of what stdout and stderr we
    are to capture.

    :param capsys: Capture sys out.
    """

    def __init__(self, capsys: pytest.CaptureFixture) -> None:
        self.capsys = capsys

    @staticmethod
    def regex(out: str) -> str:
        """Replace ANSI color codes with empty strings.

        Prefer to test colored output this way as colored strings can be
        tricky and the effort in testing their validity really isn't
        worth it. Also, hard to read expected strings when they contain
        the codes.

        :param out: String to strip of ANSI escape codes.
        :return: Same string but without ANSI codes.
        """
        ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
        return ansi_escape.sub("", out)

    def readouterr(self) -> t.Tuple[str, ...]:
        """Call as capsys ``readouterr`` but regex the strings.

        :return: A tuple (just like the capsys) containing stdout in the
            first index and stderr in the second.
        """
        out = self.capsys.readouterr()
        return tuple(self.regex(r) for r in out)

    def stdout(self) -> str:
        """Return the stdout without referencing the tuple indices.

        :return: String stripped of ANSI escape codes.
        """
        return self.readouterr()[0]

    def stderr(self) -> str:
        """Return the stdout without referencing the tuple indices.

        :return: String stripped of ANSI escape codes.
        """
        return self.readouterr()[1]


class BorgCommands:
    """Read the kwargs supplied into a mock of the command output.

    :param kwargs: Various ini config kwargs.
    """

    def __init__(self, **kwargs):
        self.datetime = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        self.sections = self.get_sections(**kwargs)
        self.default = self.sections["DEFAULT"]
        self.ssh = self.sections["SSH"]
        self.backups = self.sections["BACKUP"]
        self.prune = self.sections["PRUNE"]
        self.is_ssh = self.default.get("ssh", True)

    @staticmethod
    def get_sections(**kwargs: str) -> t.Dict[str, t.Any]:
        """Get all sections that belong to the ``ConfigParser`` object.

        Allow for empty dictionary values as default values are in place
        for all output if a keyword arg is not supplied.

        :param kwargs: Values generated by the tester which should
            contain each of the below values but may not in some tests.
        :return: Dictionary of the four sections for the config file.
        """
        sections = ["DEFAULT", "SSH", "BACKUP", "PRUNE"]
        return {s: kwargs.get(s, {}) for s in sections}

    @staticmethod
    def _boolean_switch(
        obj: t.Dict[str, bool], key: str, default: bool = True
    ) -> str:
        return f"  --{key}\n" if obj.get(key, default) else ""

    @staticmethod
    def _kwargs(obj: t.Dict[str, str], key: str, default: str) -> str:
        return f"  --{key} {obj.get(key, default)}"

    def _backup_args(self) -> str:
        keys = ["verbose", "stats", "list", "show-rc", "exclude-caches"]
        flags = "".join([self._boolean_switch(self.backups, k) for k in keys])
        return (
            f"{flags}"
            f"{self._kwargs(self.backups, 'filter', 'AME')}\n"
            f"{self._kwargs(self.backups, 'compression', 'lz4')}\n"
        )

    def _prune_args(self) -> str:
        keys = ["stats", "list", "show-rc"]
        flags = "".join([self._boolean_switch(self.prune, k) for k in keys])
        return (
            f"{self._boolean_switch(self.prune, 'verbose', default=False)}"
            f"{flags}"
        )

    def _keep_args(self) -> str:
        return (
            f"{self._kwargs(self.prune, 'keep-daily', '7')}\n"
            f"{self._kwargs(self.prune, 'keep-weekly', '4')}\n"
            f"{self._kwargs(self.prune, 'keep-monthly', '6')}\n\n"
        )

    def _ssh_args(self) -> t.Tuple[str, str, str]:
        remoteuser = self.ssh.get("remoteuser", USER)
        remotehost = self.ssh.get("remotehost", HOST)
        port = self.ssh.get("port", "22")
        return remoteuser, remotehost, port

    def _repo_fullpath(self) -> str:
        remoteuser, remotehost, port = self._ssh_args()
        return f"ssh://{remoteuser}@{remotehost}:{port}" if self.is_ssh else ""

    def _backup_path(self, fullpath: str, reponame: str) -> str:
        return f"  {fullpath}::{reponame}-{self.datetime}\n"

    def _get_fullpath(self, reponame: str) -> str:
        fullremote = self._repo_fullpath()
        repopath = self.default.get(REPOPATH, DEVNULL)
        return f"{fullremote}{repopath}/{reponame}"

    @staticmethod
    def _exclude_args() -> str:
        exclude = [
            "'/home/*/.cache/*'",
            "'/var/cache/*'",
            "'/var/tmp/*'",
            "'/var/run'",
        ]
        return "".join(f"  --exclude {e}\n" for e in exclude)

    @staticmethod
    def _include_args() -> str:
        include = ["'/home'", "'/root'", "'/var'", "'/usr/local'", "'/srv'"]
        return "".join(f"  {i}\n" for i in include)

    def commands(self) -> str:
        """Return a string matching the output from tests provided.

        :return: String to match against test output.
        """
        reponame = self.default.get(REPONAME, HOST)
        fullpath = self._get_fullpath(reponame)
        backup_path = self._backup_path(fullpath, reponame)
        return (
            f"{BORG_BIN} create\n"
            f"{self._backup_args()}"
            f"{self._exclude_args()}"
            f"{backup_path}"
            f"{self._include_args()}\n"
            f"{BORG_BIN} prune\n"
            f"{self._prune_args()}"
            f"  {fullpath}\n"
            f"{self._keep_args()}"
        )


StarredNoRetFixture = t.Callable[..., None]
StarredRetStrFixture = t.Callable[..., str]
MockMainFixture = StarredNoRetFixture
UpdateConfigFixture = StarredNoRetFixture
InitializeProfileFixture = t.Callable[
    [MockMainFixture, t.Union[str, os.PathLike], NoColorCapsys, str], str
]
RemoveFixture = t.Callable[[MockMainFixture, NoColorCapsys], str]
RandOpts = t.Dict[str, t.Any]
RandOptsFixture = t.Callable[..., RandOpts]
InvalidKeyfileFixture = StarredRetStrFixture
ListArgFixture = StarredRetStrFixture
InitializeFilesExpectedFixture = t.Callable[[str], str]
EditPathArgFixture = t.Callable[[t.Union[str, os.PathLike]], str]
