"""
tests
=====
"""
import datetime
import getpass
import re
import shutil
import socket

USER = getpass.getuser()
HOST = socket.gethostname()
BORG = shutil.which("borg") if shutil.which("borg") else "borg"


class NoColorCapsys:
    """Capsys but with a regex to remove ANSI escape codes.

    Class is preferable for this as we can instantiate the instance
    as a fixture that also contains the same attributes as capsys

    We can make sure that the class is instantiated without executing
    capsys immediately thus losing control of what stdout and stderr
    we are to capture

    :param capsys: ``pytest's`` builtin fixture to capture system output
    """

    def __init__(self, capsys):
        self.capsys = capsys

    @staticmethod
    def regex(out):
        """Replace ANSI color codes with empty strings i.e. remove all
        escape codes.

        Prefer to test colored output this way as colored strings can
        be tricky and the effort in testing their validity really isn't
        worth it. Also hard to read expected strings when they contain
        the codes.

        :param out: String to strip of ANSI escape codes
        :return:    Same string but without ANSI codes
        """
        ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
        return ansi_escape.sub("", out)

    def readouterr(self):
        """Call as capsys ``readouterr`` but regex the strings for
        escape codes at the same time.

        :return:    A tuple (just like the capsys) containing stdout in
                    the first index and stderr in the second
        """
        out = self.capsys.readouterr()
        return tuple(self.regex(r) for r in out)

    def stdout(self):
        """Call this to return the stdout without referencing the tuple
        indices."""
        return self.readouterr()[0]

    def stderr(self):
        """Call this to return the stderr without referencing the tuple
        indices."""
        return self.readouterr()[1]


class BorgCommands:
    """Read the kwargs supplied into a mock of the command output
    executed after parsing the config information."""

    def __init__(self, **kwargs):
        self.datetime = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        self.sections = self.get_sections(**kwargs)
        self.default = self.sections["DEFAULT"]
        self.ssh = self.sections["SSH"]
        self.backups = self.sections["BACKUP"]
        self.prune = self.sections["PRUNE"]
        self.is_ssh = self.default.get("ssh", True)

    @staticmethod
    def get_sections(**kwargs):
        """Get all sections that belong to the
        ``configparser.ConfigParser`` object once the config file is
        parsed.

        Allow for empty dictionary values as default values are in place
        for all output if a keyword arg is not supplied

        :param kwargs:  Values generated by the tester which should
                        contain each of the below values but may not in
                        some tests
        :return:        Dictionary of the four sections for the config
                        file
        """
        sections = ["DEFAULT", "SSH", "BACKUP", "PRUNE"]
        return {s: kwargs.get(s, {}) for s in sections}

    @staticmethod
    def _boolean_switch(obj, key, default=True):
        return f"  --{key}\n" if obj.get(key, default) else ""

    @staticmethod
    def _kwargs(obj, key, default):
        return f"  --{key} {obj.get(key, default)}"

    def _backup_args(self):
        keys = ["verbose", "stats", "list", "show-rc", "exclude-caches"]
        flags = "".join([self._boolean_switch(self.backups, k) for k in keys])
        return (
            f"{flags}"
            f"{self._kwargs(self.backups, 'filter', 'AME')}\n"
            f"{self._kwargs(self.backups, 'compression', 'lz4')}\n"
        )

    def _prune_args(self):
        keys = ["stats", "list", "show-rc"]
        flags = "".join([self._boolean_switch(self.prune, k) for k in keys])
        return (
            f"{self._boolean_switch(self.prune, 'verbose', default=False)}"
            f"{flags}"
        )

    def _keep_args(self):
        return (
            f"{self._kwargs(self.prune, 'keep-daily', '7')}\n"
            f"{self._kwargs(self.prune, 'keep-weekly', '4')}\n"
            f"{self._kwargs(self.prune, 'keep-monthly', '6')}\n\n"
        )

    def _ssh_args(self):
        remoteuser = self.ssh.get("remoteuser", USER)
        remotehost = self.ssh.get("remotehost", HOST)
        port = self.ssh.get("port", "22")
        return remoteuser, remotehost, port

    def _repo_fullpath(self):
        remoteuser, remotehost, port = self._ssh_args()
        return f"ssh://{remoteuser}@{remotehost}:{port}" if self.is_ssh else ""

    def _backup_path(self, fullpath, reponame):
        return f"  {fullpath}::{reponame}-{self.datetime}\n"

    def _get_fullpath(self, reponame):
        fullremote = self._repo_fullpath()
        repopath = self.default.get("repopath", "/dev/null")
        return f"{fullremote}{repopath}/{reponame}"

    @staticmethod
    def _exclude_args():
        exclude = [
            "'/home/*/.cache/*'",
            "'/var/cache/*'",
            "'/var/tmp/*'",
            "'/var/run'",
        ]
        return "".join(f"  --exclude {e}\n" for e in exclude)

    @staticmethod
    def _include_args():
        include = [
            "'/home'",
            "'/root'",
            "'/var'",
            "'/usr/local'",
            "'/srv'",
        ]
        return "".join(f"  {i}\n" for i in include)

    def commands(self):
        """Return a string that should match up with the output from the
        tests provided the tests are passing."""
        reponame = self.default.get("reponame", HOST)
        fullpath = self._get_fullpath(reponame)
        backup_path = self._backup_path(fullpath, reponame)
        return (
            f"{BORG} create\n"
            f"{self._backup_args()}"
            f"{self._exclude_args()}"
            f"{backup_path}"
            f"{self._include_args()}\n"
            f"{BORG} prune\n"
            f"{self._prune_args()}"
            f"  {fullpath}\n"
            f"{self._keep_args()}"
        )
